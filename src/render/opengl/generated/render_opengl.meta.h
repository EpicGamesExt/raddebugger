// Copyright (c) 2024 Epic Games Tools
// Licensed under the MIT license (https://opensource.org/license/mit/)

//- GENERATED CODE

#ifndef RENDER_OPENGL_META_H
#define RENDER_OPENGL_META_H

typedef enum R_OGL_ShaderKind
{
R_OGL_ShaderKind_Rect,
R_OGL_ShaderKind_Blur,
R_OGL_ShaderKind_COUNT,
} R_OGL_ShaderKind;

C_LINKAGE_BEGIN
extern String8 r_ogl_shader_kind_name_table[2];
extern String8 * r_ogl_shader_kind_vshad_src_table[2];
extern String8 * r_ogl_shader_kind_pshad_src_table[2];
extern R_OGL_AttributeArray r_ogl_shader_kind_input_attributes_table[2];
extern R_OGL_AttributeArray r_ogl_shader_kind_output_attributes_table[2];
read_only global String8 r_ogl_rect_vshad_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"\n"
"in vec4 c2v_dst_rect;\n"
"in vec4 c2v_src_rect;\n"
"in vec4 c2v_colors_0;\n"
"in vec4 c2v_colors_1;\n"
"in vec4 c2v_colors_2;\n"
"in vec4 c2v_colors_3;\n"
"in vec4 c2v_corner_radii;\n"
"in vec4 c2v_style;  // x: border_thickness_px, y: softness_px, z: omit_texture, w: unused\n"
"\n"
"out vec2 v2p_sdf_sample_pos;\n"
"out vec2 v2p_texcoord_pct;\n"
"out vec2 v2p_rect_half_size_px;\n"
"out vec4 v2p_tint;\n"
"out float v2p_corner_radius;\n"
"out float v2p_border_thickness;\n"
"out float v2p_softness;\n"
"out float v2p_omit_texture;\n"
"\n"
"uniform sampler2D u_tex_color;\n"
"uniform vec2 u_viewport_size_px;\n"
"\n"
"void main(void)\n"
"{\n"
"  // rjf: constants\n"
"  vec2 vertices[] = vec2[](vec2(-1, -1), vec2(-1, +1), vec2(+1, -1), vec2(+1, +1));\n"
"  \n"
"  // rjf: find dst position\n"
"  vec2 dst_half_size = (c2v_dst_rect.zw - c2v_dst_rect.xy) / 2;\n"
"  vec2 dst_center    = (c2v_dst_rect.zw + c2v_dst_rect.xy) / 2;\n"
"  vec2 dst_position  = vertices[gl_VertexID] * dst_half_size + dst_center;\n"
"  \n"
"  // rjf: find src position\n"
"  vec2 src_half_size = (c2v_src_rect.zw - c2v_src_rect.xy) / 2;\n"
"  vec2 src_center    = (c2v_src_rect.zw + c2v_src_rect.xy) / 2;\n"
"  vec2 src_position  = vertices[gl_VertexID] * src_half_size + src_center;\n"
"  \n"
"  // rjf: find color\n"
"  vec4 colors[] = vec4[](c2v_colors_0, c2v_colors_1, c2v_colors_2, c2v_colors_3);\n"
"  vec4 color = colors[gl_VertexID];\n"
"  \n"
"  // rjf: find corner radius\n"
"  float corner_radii[] = float[](c2v_corner_radii.x, c2v_corner_radii.y, c2v_corner_radii.z, c2v_corner_radii.w);\n"
"  float corner_radius = corner_radii[gl_VertexID];\n"
"  \n"
"  // rjf: fill outputs\n"
"  vec2 dst_verts_pct = vec2(((gl_VertexID >> 1) != 1) ? 1.f : 0.f,\n"
"                            ((gl_VertexID & 1) != 0)  ? 0.f : 1.f);\n"
"  ivec2 u_tex_color_size_i = textureSize(u_tex_color, 0);\n"
"  vec2 u_tex_color_size = vec2(float(u_tex_color_size_i.x), float(u_tex_color_size_i.y));\n"
"  {\n"
"    gl_Position = vec4(2 * dst_position.x / u_viewport_size_px.x - 1,\n"
"                       2 * (1 - dst_position.y / u_viewport_size_px.y) - 1,\n"
"                       0.0, 1.0);\n"
"    v2p_sdf_sample_pos    = (2.f * dst_verts_pct - 1.f) * dst_half_size;\n"
"    v2p_texcoord_pct      = src_position / u_tex_color_size;\n"
"    v2p_rect_half_size_px = dst_half_size;\n"
"    v2p_tint              = color;\n"
"    v2p_corner_radius     = corner_radius;\n"
"    v2p_border_thickness  = c2v_style.x;\n"
"    v2p_softness          = c2v_style.y;\n"
"    v2p_omit_texture      = c2v_style.z;\n"
"  }\n"
"}\n"
""
);

read_only global String8 r_ogl_rect_pshad_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"\n"
"in vec2 v2p_sdf_sample_pos;\n"
"in vec2 v2p_texcoord_pct;\n"
"in vec2 v2p_rect_half_size_px;\n"
"in vec4 v2p_tint;\n"
"in float v2p_corner_radius;\n"
"in float v2p_border_thickness;\n"
"in float v2p_softness;\n"
"in float v2p_omit_texture;\n"
"\n"
"out vec4 final_color;\n"
"\n"
"uniform float u_opacity;\n"
"uniform sampler2D u_tex_color;\n"
"uniform mat4 u_texture_sample_channel_map;\n"
"\n"
"float rect_sdf(vec2 sample_pos, vec2 rect_half_size, float r)\n"
"{\n"
"  return length(max(abs(sample_pos) - rect_half_size + r, 0.0)) - r;\n"
"}\n"
"\n"
"float linear_from_srgb_f32(float x)\n"
"{\n"
"  return x < 0.0404482362771082 ? x / 12.92 : pow((x + 0.055) / 1.055, 2.4);\n"
"}\n"
"\n"
"vec4 linear_from_srgba(vec4 v)\n"
"{\n"
"  vec4 result = vec4(linear_from_srgb_f32(v.x),\n"
"                     linear_from_srgb_f32(v.y),\n"
"                     linear_from_srgb_f32(v.z),\n"
"                     v.w);\n"
"  return result;\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"  // rjf: sample texture\n"
"  vec4 albedo_sample = vec4(1, 1, 1, 1);\n"
"  if(v2p_omit_texture < 1)\n"
"  {\n"
"    albedo_sample = u_texture_sample_channel_map * texture(u_tex_color, v2p_texcoord_pct);\n"
"    albedo_sample = linear_from_srgba(albedo_sample);\n"
"  }\n"
"  \n"
"  // rjf: sample for borders\n"
"  float border_sdf_t = 1;\n"
"  if(v2p_border_thickness > 0)\n"
"  {\n"
"    float border_sdf_s = rect_sdf(v2p_sdf_sample_pos,\n"
"                                  v2p_rect_half_size_px - vec2(v2p_softness*2.f, v2p_softness*2.f) - v2p_border_thickness,\n"
"                                  max(v2p_corner_radius-v2p_border_thickness, 0));\n"
"    border_sdf_t = smoothstep(0, 2*v2p_softness, border_sdf_s);\n"
"  }\n"
"  if(border_sdf_t < 0.001f)\n"
"  {\n"
"    discard;\n"
"  }\n"
"  \n"
"  // rjf: sample for corners\n"
"  float corner_sdf_t = 1;\n"
"  if(v2p_corner_radius > 0 || v2p_softness > 0.75f)\n"
"  {\n"
"    float corner_sdf_s = rect_sdf(v2p_sdf_sample_pos,\n"
"                                  v2p_rect_half_size_px - vec2(v2p_softness*2.f, v2p_softness*2.f),\n"
"                                  v2p_corner_radius);\n"
"    corner_sdf_t = 1-smoothstep(0, 2*v2p_softness, corner_sdf_s);\n"
"  }\n"
"  \n"
"  // rjf: form+return final color\n"
"  final_color = albedo_sample;\n"
"  final_color *= v2p_tint;\n"
"  final_color.a *= u_opacity;\n"
"  final_color.a *= corner_sdf_t;\n"
"  final_color.a *= border_sdf_t;\n"
"}\n"
""
);

read_only global String8 r_ogl_blur_vshad_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"\n"
"uniform vec4 rect;\n"
"uniform vec4 corner_radii_px;\n"
"uniform vec2 viewport_size;\n"
"uniform uint blur_count;\n"
"\n"
"out vec2 texcoord;\n"
"out vec2 sdf_sample_pos;\n"
"out vec2 rect_half_size;\n"
"out float corner_radius;\n"
"\n"
"void main(void)\n"
"{\n"
"  vec2 vertex_positions_scrn[] = vec2[](rect.xw,\n"
"                                        rect.xy,\n"
"                                        rect.zw,\n"
"                                        rect.zy);\n"
"  float corner_radii_px[] = float[](corner_radii_px.y,\n"
"                                    corner_radii_px.x,\n"
"                                    corner_radii_px.w,\n"
"                                    corner_radii_px.z);\n"
"  vec2 cornercoords_pct = vec2((gl_VertexID >> 1) != 0 ? 1.f : 0.f,\n"
"                               (gl_VertexID & 1) != 0  ? 0.f : 1.f);\n"
"  \n"
"  vec2 vertex_position_pct = vertex_positions_scrn[gl_VertexID] / viewport_size;\n"
"  vec2 vertex_position_scr = 2.f * vertex_position_pct - 1.f;\n"
"  \n"
"  vec2 rect_half_size = vec2((rect.z-rect.x)/2, (rect.w-rect.y)/2);\n"
"  \n"
"  gl_Position = vec4(vertex_position_scr.x, -vertex_position_scr.y, 0.f, 1.f);\n"
"  texcoord = vertex_position_pct;\n"
"  sdf_sample_pos = (2.f * cornercoords_pct - 1.f) * rect_half_size;\n"
"  rect_half_size = rect_half_size - 2.f;\n"
"  corner_radius = corner_radii_px[gl_VertexID];\n"
"}\n"
""
);

read_only global String8 r_ogl_blur_pshad_src =
str8_lit_comp(
""
"\n"
"#version 330 core\n"
"\n"
"uniform sampler2D tex;\n"
"uniform vec4 kernel[32];\n"
"uniform int blur_count;\n"
"uniform vec2 direction;\n"
"\n"
"in vec2 texcoord;\n"
"in vec2 sdf_sample_pos;\n"
"in vec2 rect_half_size;\n"
"in float corner_radius;\n"
"\n"
"out vec4 final_color;\n"
"\n"
"float rect_sdf(vec2 sample_pos, vec2 rect_half_size, float r)\n"
"{\n"
"  return length(max(abs(sample_pos) - rect_half_size + r, 0.0)) - r;\n"
"}\n"
"\n"
"void main(void)\n"
"{\n"
"  // rjf: blend weighted texture samples into color\n"
"  vec3 color = kernel[0].x * texture(tex, texcoord).rgb;\n"
"  \n"
"  for(int i = 1; i < blur_count; i += 1)\n"
"  {\n"
"    float weight = kernel[i].x;\n"
"    float offset = kernel[i].y;\n"
"    color += weight * texture(tex, texcoord - offset * direction).rgb;\n"
"    color += weight * texture(tex, texcoord + offset * direction).rgb;\n"
"  }\n"
"  \n"
"  // rjf: sample for corners\n"
"  float corner_sdf_s = rect_sdf(sdf_sample_pos, rect_half_size, corner_radius);\n"
"  float corner_sdf_t = 1-smoothstep(0, 2, corner_sdf_s);\n"
"  \n"
"  // rjf: weight output color by sdf\n"
"  // this is doing alpha testing, leave blurring only where mostly opaque pixels are\n"
"  if(corner_sdf_t < 0.9f)\n"
"  {\n"
"    discard;\n"
"  }\n"
"  \n"
"  final_color = vec4(color, 1.f);\n"
"}\n"
""
);


C_LINKAGE_END

#endif // RENDER_OPENGL_META_H
